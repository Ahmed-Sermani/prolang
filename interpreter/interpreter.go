package interpreter

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/Ahmed-Sermani/prolang/interpreter/environment"
	"github.com/Ahmed-Sermani/prolang/parser/expressions"
	"github.com/Ahmed-Sermani/prolang/parser/statements"
	"github.com/Ahmed-Sermani/prolang/reporting"
	"github.com/Ahmed-Sermani/prolang/scanner"
)

// Runtime errors
type InterpretationError struct {
	token expressions.Token
	msg   string
}

// implementing the error interface
func (e *InterpretationError) Error() string {
	if e.msg == "" {
		e.msg = "error while interpreting expressions"
	}
	return e.msg + fmt.Sprintf("[line %d]", e.token.Line)
}

type ErrorOpNumMismatch struct {
	InterpretationError
}

type ObjNotCallable struct {
	InterpretationError
}

type ArgsNumMismatch struct {
	InterpretationError
}

type InvalidPropertyAccess struct {
	InterpretationError
}

type UndefinedProperty struct {
	InterpretationError
}

type InvalidFieldAssignment struct {
	InterpretationError
}

type InvalidSuperclass struct {
	InterpretationError
}

// error to handle unwind for return statement
type ErrorHandleReturn struct {
	value interface{}
}

func (e ErrorHandleReturn) Error() string {
	return ""
}

type Locals map[expressions.Experssion]*int

// implement expression visitor and statement visitor interface
type Interpreter struct {
	// current scope pointer
	environment *environment.Environment
	// top level scope pointer
	globals *environment.Environment
	// stores resolution information generated by the resolver
	locals Locals
}

func New() *Interpreter {
	envPtr := environment.New(nil)
	return &Interpreter{
		environment: envPtr,
		globals:     envPtr,
		locals:      Locals{},
	}
}

func (inter *Interpreter) Interpret(stmts []statements.Statement) error {
	for _, stmt := range stmts {
		err := inter.execute(stmt)
		if err != nil {
			reporting.ReportRuntimeError(err)
			return err
		}
	}

	return nil
}

func (inter *Interpreter) execute(stmt statements.Statement) error {
	return stmt.Accept(inter)
}

// the runtime value was produced during scanning and it in the token.
// The parser took the value and stuck it in the literal tree node,
// so to evaluate a literal pull it back out.
func (inter *Interpreter) VisitLiteral(expr expressions.Literal) (interface{}, error) {
	return expr.Value, nil
}

// grouping node has a reference to an inner node for the expression contained inside the parentheses.
// recursively evaluate that subexpression and return it.
func (inter *Interpreter) VisitGrouping(expr expressions.Grouping) (interface{}, error) {
	return inter.evaluate(expr.Expr)
}

// evaluate the operand expression. Then apply the unary operator itself to the result of that.
// There are two different unary expressions, identified by the type of the operator token.
func (inter *Interpreter) VisitUnary(expr expressions.Unary) (interface{}, error) {
	right, err := inter.evaluate(expr.Right)
	if err != nil {
		return nil, err
	}

	switch expr.Operator.Kind {
	case scanner.MINUS:
		refVal := reflect.ValueOf(right)
		val, err := reflectFloat64(refVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		// negating the right operand in case of minus operator
		return -val, nil
	case scanner.BANG:
		refVal := reflect.ValueOf(right)
		// applying the ! operator
		return !isTruthy(refVal), nil
	}

	return nil, &InterpretationError{token: expr.Operator}
}

func (inter *Interpreter) VisitBinary(expr expressions.Binary) (interface{}, error) {

	left, err := inter.evaluate(expr.Left)
	if err != nil {
		return nil, &InterpretationError{token: expr.Operator}
	}
	right, err := inter.evaluate(expr.Right)
	if err != nil {
		return nil, &InterpretationError{token: expr.Operator}
	}

	switch expr.Operator.Kind {

	// arithmetic operator
	case scanner.MINUS:
		lRefVal := reflect.ValueOf(left)
		lVal, err := reflectFloat64(lRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		rRefVal := reflect.ValueOf(right)
		rVal, err := reflectFloat64(rRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}

		return (lVal - rVal), nil

	case scanner.SLASH:
		lRefVal := reflect.ValueOf(left)
		lVal, err := reflectFloat64(lRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		rRefVal := reflect.ValueOf(right)
		rVal, err := reflectFloat64(rRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}

		return (lVal / rVal), nil

	case scanner.STAR:
		lRefVal := reflect.ValueOf(left)
		lVal, err := reflectFloat64(lRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		rRefVal := reflect.ValueOf(right)
		rVal, err := reflectFloat64(rRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}

		return (lVal * rVal), nil
	// + supports additions on numbers and concatenation on strings
	case scanner.PLUS:
		lRefVal := reflect.ValueOf(left)
		rRefVal := reflect.ValueOf(right)
		if lRefVal.Kind() == reflect.Float64 && rRefVal.Kind() == reflect.Float64 {
			return lRefVal.Float() + rRefVal.Float(), nil
		} else if lRefVal.Kind() == reflect.String && rRefVal.Kind() == reflect.String {
			return lRefVal.String() + rRefVal.String(), nil
		} else {
			return nil, &ErrorOpNumMismatch{
				InterpretationError{
					token: expr.Operator,
					msg:   "Operands must be two numbers or two strings",
				},
			}
		}
	// comparison operators
	case scanner.GREATER:
		lRefVal := reflect.ValueOf(left)
		lVal, err := reflectFloat64(lRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		rRefVal := reflect.ValueOf(right)
		rVal, err := reflectFloat64(rRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		return lVal > rVal, nil
	case scanner.GREATER_EQUAL:
		lRefVal := reflect.ValueOf(left)
		lVal, err := reflectFloat64(lRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		rRefVal := reflect.ValueOf(right)
		rVal, err := reflectFloat64(rRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		return lVal >= rVal, nil
	case scanner.LESS:
		lRefVal := reflect.ValueOf(left)
		lVal, err := reflectFloat64(lRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		rRefVal := reflect.ValueOf(right)
		rVal, err := reflectFloat64(rRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		return lVal < rVal, nil
	case scanner.LESS_EQUAL:
		lRefVal := reflect.ValueOf(left)
		lVal, err := reflectFloat64(lRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		rRefVal := reflect.ValueOf(right)
		rVal, err := reflectFloat64(rRefVal, expr.Operator)
		if err != nil {
			return nil, err
		}
		return lVal <= rVal, nil
	// equality
	case scanner.EQUAL_EQUAL:
		return isEqual(left, right), nil
	case scanner.BANG_EQUAL:
		return !isEqual(left, right), nil
	}

	return nil, &InterpretationError{token: expr.Operator}
}

func (inter *Interpreter) VisitVairable(expr expressions.Variable) (interface{}, error) {
	return inter.lookUpVar(expr.Token, expr)
}

// evaluates the r-value.
// then stores it in the named variable
func (inter *Interpreter) VisitAssgin(expr expressions.Assgin) (interface{}, error) {
	value, err := inter.evaluate(expr.Value)
	if err != nil {
		return nil, err
	}

	level := inter.locals[expr]
	if level != nil {
		err := inter.environment.AssginAt(*level, expr.Token, value)
		if err != nil {
			return nil, err
		}
	} else {
		err := inter.environment.Assgin(expr.Token, value)
		if err != nil {
			return nil, err
		}
	}
	return value, nil
}

func (inter *Interpreter) VisitLogical(expr expressions.Logical) (interface{}, error) {
	left, err := inter.evaluate(expr.Left)
	if err != nil {
		return nil, err
	}
	refVal := reflect.ValueOf(left)
	if expr.Operator.Kind == scanner.OR && isTruthy(refVal) {
		return left, nil
	} else if !isTruthy(refVal) {
		return left, nil
	}

	return inter.evaluate(expr.Right)
}

func (inter *Interpreter) VisitCall(expr expressions.Call) (interface{}, error) {
	callee, err := inter.evaluate(expr.Callee)
	if err != nil {
		return nil, err
	}
	args := []interface{}{}
	for _, arg := range expr.Args {
		evaluatedArg, err := inter.evaluate(arg)
		if err != nil {
			return nil, err
		}
		args = append(args, evaluatedArg)

	}
	function, ok := callee.(Callable)
	if !ok {
		return nil, &ObjNotCallable{
			InterpretationError: InterpretationError{
				msg: fmt.Sprintf("Object %s is not callable", callee),
			},
		}
	}

	if len(args) != function.ArgsNum() {
		return nil, &ObjNotCallable{
			InterpretationError: InterpretationError{
				msg: fmt.Sprintf("Function %s does not have the correct number of arguments", callee),
			},
		}
	}
	return function.Call(inter, args)

}

func (inter *Interpreter) VisitPropertyAccess(expr expressions.PropertyAccess) (interface{}, error) {
	obj, err := inter.evaluate(expr.Obj)
	if err != nil {
		return nil, err
	}
	instance, ok := obj.(*Instance)
	if ok {
		property, err := instance.Get(expr.Name)
		if err != nil {
			return nil, err
		}
		return property, nil
	}

	err = &InvalidPropertyAccess{
		InterpretationError: InterpretationError{
			msg: "not an instance, only instances have properties ",
		},
	}
	return nil, err

}

func (inter *Interpreter) VisitPropertyAssignment(expr expressions.PropertyAssignment) (interface{}, error) {
	obj, err := inter.evaluate(expr.Obj)
	if err != nil {
		return nil, err
	}
	instance, ok := obj.(*Instance)
	if !ok {
		return nil, &InvalidFieldAssignment{
			InterpretationError: InterpretationError{
				msg: "not an instance, field assignment only allowed on instances",
			},
		}
	}
	value, err := inter.evaluate(expr.Value)
	if err != nil {
		return nil, err
	}
	instance.Set(expr.Name, value)
	return value, nil
}

// since to bound to the method it's the same as interpreting variables expression
func (inter *Interpreter) VisitThis(expr expressions.This) (interface{}, error) {
	return inter.lookUpVar(expr.Keywork, expr)
}

func (inter *Interpreter) VisitSuper(expr expressions.Super) (interface{}, error) {
	// looking up 'super' in the proper env
	level := inter.locals[expr]
	superclass, err := inter.environment.GetAt(*level, expressions.Token{Lexeme: "super"})
	if err != nil {
		return nil, err
	}
	// getting 'this' from the previous environment
	this, err := inter.environment.GetAt(*level-1, expressions.Token{Lexeme: "this"})
	if err != nil {
		return nil, err
	}
	super := superclass.(*ClassCallable)
	method := super.lookForMethod(expr.Method.Lexeme)
	if method == nil {
		return nil, &UndefinedProperty{
			InterpretationError: InterpretationError{
				msg: "Undefined property " + expr.Method.Lexeme,
			},
		}
	}
	instance, ok := this.(*Instance)
	if !ok {
		return nil, &InterpretationError{msg: "Undefined Instance"}
	}
	return method.bind(instance), nil
}

func (inter *Interpreter) VisitExprStmt(stmt statements.ExperssionStatement) error {
	_, err := inter.evaluate(stmt.Expr)
	return err

}

func (inter *Interpreter) VisitPrintStmt(stmt statements.PrintStatement) error {
	val, err := inter.evaluate(stmt.Expr)
	if err != nil {
		return err
	}
	fmt.Println(stringify(val))
	return err

}

// evaluate the initializer of exists
// vairable decleration without initializer is allowed
func (inter *Interpreter) VisitVarDecStmt(stmt statements.VarDecStatement) error {
	var value interface{}
	if stmt.Initializer != nil {
		// evaluate initializer expression
		tvalue, err := inter.evaluate(stmt.Initializer)
		if err != nil {
			return err
		}
		value = tvalue
	}
	inter.environment.Define(stmt.Token.Lexeme, value)
	return nil
}

func (inter *Interpreter) VisitBlockStmt(stmt statements.BlockStatement) error {
	// passing the current environment into the enclosing state of sub-scope
	return inter.executeBlock(stmt.Statements, environment.New(inter.environment))
}

// evaluates the condition. If truthy, executes the then branch.
// Otherwise, if there is an else branch, execute that.
func (inter *Interpreter) VisitIfStmt(stmt statements.IfStatement) error {
	conditionValue, err := inter.evaluate(stmt.Condition)
	if err != nil {
		return err
	}
	if isTruthy(reflect.ValueOf(conditionValue)) {
		err := inter.execute(stmt.ThenBranch)
		if err != nil {
			return err
		}
	} else if stmt.ElseBranch != nil {
		err := inter.execute(stmt.ElseBranch)
		if err != nil {
			return err
		}
	}
	return nil
}

// evaluated the condition . while it's truthy execute the body
func (inter *Interpreter) VisitWhileStmt(stmt statements.WhileStatement) error {
	for {
		condiction, err := inter.evaluate(stmt.Condition)
		if err != nil {
			return err
		}
		if !isTruthy(reflect.ValueOf(condiction)) {
			break
		}
		err = inter.execute(stmt.Body)
		if err != nil {
			return nil
		}
	}
	return nil
}

// convert function parse time representation to its runtime representation
func (inter *Interpreter) VisitFunctionStmt(stmt statements.FunctionStatement) error {
	// after creating the FunctionCallable,
	// it create a new binding in the current environment and store a reference to it there.
	// binding as *FunctionCallable because FunctionCallable implements Callable interface as pointer receiver
	function := &FunctionCallable{Declaration: stmt, Closure: inter.environment}
	inter.environment.Define(stmt.Name.Lexeme, function)
	return nil
}

func (inter *Interpreter) VisitReturnStmt(stmt statements.ReturnStatement) error {

	var value interface{}
	if stmt.Value != nil {
		value1, err := inter.evaluate(stmt.Value)
		if err != nil {
			return err
		}
		value = value1
	}
	return ErrorHandleReturn{value: value}
}

func (inter *Interpreter) VisitClassStmt(stmt statements.ClassStatement) error {

	// evaluate the superclass expression if exists
	// also check that it's evaluated to a class
	var superclass interface{}
	if stmt.Superclass.Token.Lexeme != "" {
		super, err := inter.evaluate(stmt.Superclass)
		if err != nil {
			return err
		}

		if _, ok := super.(*ClassCallable); !ok {
			return &InvalidSuperclass{
				InterpretationError: InterpretationError{
					msg: "Superclass must be a class",
				},
			}
		}
		superclass = super
	}

	// two stage binding to allow referencing the class inside its own methods
	inter.environment.Define(stmt.Name.Lexeme, nil)

	// set super environment
	if stmt.Superclass.Token.Lexeme != "" {
		inter.environment = environment.New(inter.environment)
		inter.environment.Define("super", superclass)
	}

	methods := map[string]*FunctionCallable{}

	// Each method declaration converted into a FunctionCallable object
	// flag the initializer if exists
	for _, method := range stmt.Methods {
		function := &FunctionCallable{Declaration: method, Closure: inter.environment, IsInit: method.Name.Lexeme == "init"}
		methods[method.Name.Lexeme] = function
	}
	var class *ClassCallable
	super, ok := superclass.(*ClassCallable)
	if ok {
		class = &ClassCallable{name: stmt.Name.Lexeme, methods: methods, superclass: super}
	} else {
		class = &ClassCallable{name: stmt.Name.Lexeme, methods: methods}
	}

	// pop the super environment
	if stmt.Superclass.Token.Lexeme != "" {
		inter.environment = inter.environment.GetEnclosing()
	}

	err := inter.environment.Assgin(stmt.Name, class)
	return err
}

func (inter *Interpreter) executeBlock(stmts []statements.Statement, innerEnv *environment.Environment) error {
	// save the outer env
	outerEnv := inter.environment
	// replace the outer env with the inner one
	inter.environment = innerEnv
	// defer env restore That way it gets restored even if an error occurs.
	defer func() {
		inter.environment = outerEnv
	}()
	for _, stmt := range stmts {
		err := inter.execute(stmt)
		if err != nil {
			return err
		}
	}
	return nil

}

// sends the expression back into the interpreterâ€™s visitor implementation
func (inter *Interpreter) evaluate(expr expressions.Experssion) (interface{}, error) {
	return expr.Accept(inter)
}

// Append new variable resolution (used by the resolver)
func (inter *Interpreter) Resolve(expr expressions.Experssion, level int) {
	inter.locals[expr] = &level
}

// define what to consider true and false
// currently only false and nil considered falsy
func isTruthy(ref reflect.Value) bool {
	if ref.Kind() == reflect.Ptr && ref.IsNil() {
		return false
	}
	if ref.Kind() == reflect.Bool {
		return ref.Bool()
	}
	return true
}

// Interface values are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values
// or if both have value nil.
func isEqual(left interface{}, right interface{}) bool {
	return left == right
}

func reflectFloat64(ref reflect.Value, operator expressions.Token) (float64, error) {
	err := checkNumOperands(ref, operator)
	if err != nil {
		return 0.0, err
	}
	return ref.Float(), nil
}

func checkNumOperands(operand reflect.Value, operator expressions.Token) error {
	if operand.Kind() != reflect.Float64 {
		return &ErrorOpNumMismatch{
			InterpretationError{
				token: operator,
				msg:   "Operand must be a number.",
			},
		}
	}
	return nil
}

// convert obj of type interface{} into its approperate string representation
func stringify(obj interface{}) string {
	refVal := reflect.ValueOf(obj)
	if refVal.Kind() == reflect.Ptr && refVal.IsNil() {
		return "nil"
	}
	if refVal.Kind() == reflect.Float64 {
		text := fmt.Sprintf("%f", refVal.Float())

		return text
	}

	if refVal.Kind() == reflect.Bool {
		return strconv.FormatBool(refVal.Bool())
	}

	if refVal.Kind() == reflect.Ptr {
		// handle stringer on pointer receiver
		stringerFunc := refVal.MethodByName("String")
		if stringerFunc.IsValid() {
			output := stringerFunc.Call([]reflect.Value{})
			if len(output) != 0 {
				return output[0].String()
			}
		}
	}

	return refVal.String()
}

func (inter *Interpreter) lookUpVar(name expressions.Token, expr expressions.Experssion) (interface{}, error) {
	level := inter.locals[expr]
	if level != nil {
		return inter.environment.GetAt(*level, name)
	}
	return inter.globals.Get(name)

}
